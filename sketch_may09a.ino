/*
   公式日本語リファレンス
   http://www.musashinodenpa.com/arduino/ref/
   これを見れば基本はバッチリ！
   このプログラムは簡単な書き方特集、参考程度にしてね
*/


#define LED_PIN 13
/* 定義
   このプログラムにおいてLED_PINは13という意味になる
   メリット：変数と違って変更不可なのでピンが勝手に変わったりしない
   arduino nanoなどのようにメモリの少ないものの場合、defineでピンを定義するとメモリを専有しない
   （直接書かれた数字として扱われる）
   結論：ピン番号など変更のないものはこれを使おう！
*/

int a = 1;    //整数の型
float b = 1.5;   //小数の方
char c = 'A'; //半角英字1文字 ’’で囲んで使う
bool d = true; //yes か no の2択が使えるプログラムの世界ではyesはtrue、noはfalseで表す
/* グローバル変数
   プログラム全体で使うことのできる変数
   メリット：プログラム全体で使える（関数の中外関係なく使える）。
   　　　　　値の保存ができる。
   デメリット：使いすぎるとバグなどが起きたとき、解決が大変になる
   　　　　　メモリを専有する。

   結論：可能な限りローカル変数（後述）を使おう！
   　　　でも必要に応じて遠慮することはないよ。
*/

const int e = 100; //constは値を最初の代入値で固定させる。変更不可にする

int f[3];
float g[] = {0, 0, 0, 0};
int h[4][2];
int [4][] = {{1, 2}, {1, 2}, {1, 2}, {1, 2}};
/*配列
   一つの変数に複数のデータ（同じ型で）を保存することができる
   3つ目は2重配列
   使うときはf[0]のように使う
   f[3]の場合、f[0]~f[2]の3種類。
   プログラム全ては0から始まる
*/

void setup() {
  /*
     最初に1回だけ実行されるプログラム。
     pinModeやSerial、i2cの初期化をここで行おう
  */

  pinMode(2, OUTPUT);
  pinMode(3, INPUT);
  /*
     pinMode(ピン番号, 役割);
     ピン番号は使うマイコンによって異なる。
     役割はOUTPUT、INPUT、INPUT＿PULLUP、INPUT_PULLDOWNの4種類
     アナログピンはA3のように記載するが、pinModeで指定する必要はない。（入力しかできないから）
  */

  Serial.begin(115200);
  /*
     シリアル通信の初期化
     カッコの中はポートレート(bpm)
     だいたい9600, 38400, 115200など
     arduino MEGAなどシリアルピンが2つ以上ある場合
     Serial1 Serial2　のように増える
  */
}

void loop() {
  /*
     メインの処理を書こう
     最後まで動いたらまたここに戻ってくるよ
  */

  int local_val;
  /*
     ローカル変数
     この関数内でのみ使える関数。
     1周すると消去される
     メリット：メモリを食わない、他の関数で使えないのでバグが起きにくい。
     デメリット：1周したら消える、他の関数で使えない
  */

  static int local_val1;
  /*
     スタティック変数
     ローカル変数同様この関数内でのみ使える
     1周しても値は消えずに保存される
  */

  digitalWrite(pin, HIGH); //HIGH(1)＝ON か LOW(0)＝OFF　ができる。ロジック
  analogWrite(pin, 125); // 0~255の1byteで出力を調整できる。PWMピン出のみ行える

  digitalRead(pin); //1＝ON か ０＝OFFで読むことができる
  analogRead(A3); //0~1023でアナログ値を読める。アナログピンのみ

  int q1 = 3;
  float q2 = 4;
  int ans = 0;
  float ans1 = 0;

  ans = q1 + q2; //足し算
  ans = q1 - q2; //引き算
  ans = q1 * q2; //掛け算
  ans = q1 / q2; //割り算(ansが整数型なのでこれは0)
  ans = q1 % q2; //割り算のあまり

  ans1 = q1 / q2; 　 //割り算(ans1は小数型なのでこれは0.075)


  int enzan = 1;
  enzan ++;   //1を足す
  enzan --;   //1を引く
  enzan += 2; //2を足す
  enzan -= 2; //2を引く
  enzan *= 2; //2倍する
  enzan /= 2; //2で割る
  /*
     複合演算子
     代入とは異なり、変数を直接いじることができる。
     上2つ以外は＝の後ろの値を足したり、掛けたりする
  */


  int local_a = 0;
  if (local_a == 4) {
    //local_a が　4の場合
  } else if (local_a > 10) {
    //local_a が 10以上の場合
  } else if (local_a) {
    //local_a が0以外
  } else {
    //すべての条件に当てはまらない場合
  }
  /*
     if文
     条件で処理を分けたり、条件に合致する場合のみ処理を行わせる
     条件が合致した場合ture、合致しなければfalseになる

     条件式の種類
     a==b　　　　 、a=bなら
     a<b, a>b 　 、そのまんま(未満、bより大きい)
     a<=b, a>=b　、以下や以上
     a!=b        、a≠b

     複数の条件など
     a && b 　　　、aとbがtrue
     a || b 　　　、aかbがtrue
     !a　　　　　　、aがtrueではないときtrue
  */

  for (int i = 0; i < 5; i++) {
    //繰り返す処理
  }
  /*
     for文
     同じ処理を繰り返すことができる
     この場合iは最初0で、一周するたびにiが1ずつ増えていき
     iが5未満つまり4になったら終わり(5回繰り返したら終わり)

     for(変数の初期値; if文同様条件がtrueの間繰り返す; 一周したら変数にする作業)
     変数は慣習的にiを使う、使われていたらj,k...

     一周したら変数にする作業
     複合演算子の++ -- += -= *= /=が使える
  */

}

void method0(int data, float data1) {
  /*
     引数　関数に渡す変数
     今回は整数のdataと小数のdata1

     返り値、関数の結果を返すことができる。
     変数とほぼ同じ型が使える。
  */
  //返り値のない処理
}

int method1(int data) {
  //整数の返り値
  return data;
}

float method2(float data) {
  //小数の返り値
  return data;
}
